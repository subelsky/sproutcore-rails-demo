NOTE: Firefox with Firebug or webkit inspector

rails -v # 2.3.2
sproutcore -v # 0.9.23
sudo gem install sqlite3-ruby --no-ri --no-rdoc

rails cookbook
cd cookbook
rake db:create:all
script/server
visit http://localhost:3000/

script/generate resource recipe name:string prep_time:integer cook_time:integer

replace recipes.yml with
  one:
    name: "Macaroni and Cheese"
    prep_time: 5
    cook_time: 10

  two:
    name: "Duck l'Orange"
    prep_time: 30
    cook_time: 2400

rake db:create db:migrate db:fixtures:load   

add to recipe.rb model

  def to_hash
    attributes.except('id','updated_at','created_at').merge(:guid => self[:id], :type => "Recipe")
  end

mkdir app/presenters

create app/presenters/recipe_presenter.rb

	class RecipePresenter
  
	  def initialize(params = {})
	  end

	  def to_hash
	    { :records => records }
	  end

	  private

	  def recipes
	    @recipes ||= Recipe.find(:all)
	  end

	  def recipe_ids
	    @recipe_ids ||= recipes.collect { |r| r.id }
	  end
  
	  def records
	    @records ||= recipes.map { |recipe| recipe.to_hash }
	  end
    
	end

in the config block for environment.rb
	  config.load_paths << "#{RAILS_ROOT}/app/presenters"

script/console
	type RecipePresenter.new.to_hash
	
Add to recipes controller:

  def index
    response_hash = RecipePresenter.new.to_hash
    render :json => response_hash
  end

restart server

visit http://localhost:3000/recipes

sc-init cookbook
cd cookbook
sc-server

in browser check http://localhost:4020/cookbook

sc-gen model cookbook/recipe

add to fixtures/recipe.js

  { guid: 1,
    name: "Nachos",
    type: 'Recipe',
    prep_time: 3,
    cook_time: 1
    },
  
  { guid: 2,
    name: "Vegetable Korma",
    type: 'Recipe',
    prep_time: 45,
    cook_time: 35
    }

add to main.js
	
  Cookbook.server.preload(Cookbook.FIXTURES) ;

reload browser
Cookbook.Recipe.find(1).get('name')
Cookbook.Recipe.find(2).get('name')

- now let's hook it up to server

add to core.js
	localMode: window.location.hash === '#development';

change main.js

  if (Cookbook.localMode) {
    Cookbook.server.preload(Cookbook.FIXTURES);
		Cookbook.startup();
  } else {
    Cookbook.fetchRecipes(Cookbook.startup);		
  }

create core_app.js, add this:

Cookbook.RECIPES_COLLECTION_PATH = '/sc/recipes';

Cookbook.fetchRecipes = function(successFunction) {
  var opts = {
    onSuccess: function(transport) {
      Cookbook.parseFetchResponse(transport);
      if (successFunction) {
        successFunction(); 
      }
    },
  
    onFailure: function(transport) {
      console.warn("Recipe fetching failed due to: '%@'".fmt(transport.statusText));
    }
  };
  
  Cookbook.executeAjax(Cookbook.RECIPES_COLLECTION_PATH,'get', opts);
};

Cookbook.startup = function() {
  var recipes = Cookbook.Recipe.findAll();
  Cookbook.recipesController.set('content',recipes);
};

Cookbook.parseFetchResponse = function(transport) {
  var response = transport.responseJSON;
  var records = response.records;
  
  var idx = records.length;
  var record;
  
  while (idx--) {
    record = Cookbook.Recipe.newRecord(records[idx]);
    record.set('newRecord',false);
  }

};

Cookbook.executeAjax = function(url,method,opts) {
  opts = opts || {};
  opts.method = method;
  opts.emulateUncommonMethods = true; // so that PUT gets turned into _method: put like Rails expects

  if (!Cookbook.localMode) {
    var request = new Ajax.Request(url,opts);
  }
};

- reload browser and try, notice nothing happens -- check merb log

add to sc-config
	proxy '/sc', :url => "", :to => 'localhost:3000'

restart sc-server

reload browser, then check the SC logs and the Rails server logs

then at the console type
Cookbook.Recipe.findAll().inspect()
Cookbook.Recipe.find(####).get('name')
Cookbook.Recipe.find(####).get('name')

sc-gen controller cookbook/recipes SC.ArrayController

talk about collection controller vs array controller vs obj controller

- reload browser then type
Cookbook.recipesController.get('arrangedObjects').inspect()

change body.html
	<% content_for('body') do %>
  	<% view :sidebar do -%>
			<% scroll_view :recipes_list_scroll do -%>
      	<%= list_view :recipes_list, 
          						:row_height => 36,
          						:content_value_key => 'name', 
          						:bind => { :content => 'Cookbook.recipesController.arrangedObjects', 
                     						 :selection => 'Cookbook.recipesController.selection' }  %>

    	<% end -%>
		<% end -%>
	<% end ->

reload browser
  nothing displayed WTF?
  talk about absolute positioning

paste in body.css
	<snip>
	
reload browser in localMode and normal mode and make sure list displays
	- select an objects then type
	Cookbook.recipesController.get('selection').inspect()

  - select multiple objects
  
- talk about row_height, content_value_key, bind

then add to recipes.js
  allowsEmptySelection: false,
  allowsMultipleSelection: false

reload browser and test effects

sc-gen controller cookbook/recipe SC.ObjectController

add to recipe.js controller
  contentBinding: 'Cookbook.recipesController.selection'

reload browser and type
	Cookbook.recipeController.get('content')

talk about bug with not being able to return a singular object

in body.rhtml after sidebar add:

  <% view :main do -%>
  	<div class='row'>
  		<label>Name</label>
      <%= text_field_view :bind => { :value => 'Cookbook.recipeController.name' } %>
  	</div>

  	<div class='row'>
  	  <label>Prep Time</label>
      <%= text_field_view :bind => { :value => 'Cookbook.recipeController.prep_time' } %>
  	</div>

  	<div class='row'>
  	  <label>Cook Time</label>
      <%= text_field_view :bind => { :value => 'Cookbook.recipeController.cook_time' } %>
  	</div>

  <% end -%>

- reload browser, click around
- change the name property, see it change "real time"
	type Cookbook.recipeController.get('content').objectAt(0).set('name','Railsconf')
	explain objectAt and KVO

- notice that save button always enabled; add
	:bind => { :enabled => "Cookbook.recipeController.hasChanges" }	

- append :size => 4 to helpers

- add to recipe.js controller
  commitChangesImmediately: false

- reload and note how changes don't persist when click away

- then add inside main view:

  	<% view :toolbar do -%> 
  		<%= button_view :label => "Save", 
                			:default => true,
                      :action => 'Cookbook.recipeController.commitRecord' %>
  	<% end -%>

- add this to recipe controller

  commitRecord: function() {
    this.commitChanges();
    var content = this.get('content');
    if (content && content.get('length') == 1) {
      content.objectAt(0).commit();
    }
  }

- reload and see how changes do persist, but notice nothing going to server

- add to core_app.js

	Cookbook.RECIPES_MEMBER_PATH = '/sc/recipes/%@';

- explain %@

- add to recipe.js
  properties: ['name','prep_time','cook_time']
	
  commit: function() {
    var url = Cookbook.RECIPES_MEMBER_PATH.fmt(this.get('guid'));
    var parameters = {};
    
		// makes sure things are saved in the store, newRecord set to false, etc.
    // note this is a pretty naive implementation; this commit shouldn't succeed
		// unless the server call succeeds -- but this is good enough for tutorial purposes
		sc_super(); 
    
    // we mainly have to encode this ourselves because Ajax.Request doesn't seem to handle nested objects very well
    parameters = { recipe: $H(this.getPropertyData()).toJSON() };
    
    var opts = {
      parameters: parameters,
      onSuccess: function(transport) {
        // this ensures that the guid gets updated to match what the server thinks, and generally acts to ensure
        // the client and server are definitely in sync
        this.updateAttributes(transport.responseJSON);
      }.bind(this),
      onFailure: function(transport) {
        console.warn("Recipe commit failed due to: '%@'".fmt(transport.statusText));
      }
    };

    Cookbook.executeAjax(url,'put',opts);
  }

- reload browser and see if it works

- add cancel button whose action is "discardChanges"

- reload and try it

- try hitting escape to cancel a change, what happens?

- now add this to cancel
  		                :cancel => true,

- reload and try it with escape

- type this at console
	Cookbook.recipesController.newObject({ name: "Quiche Lorraine" })

- why didn't it show up?  need to add this to recipes controller:

  canEditCollection: true

- now let's add some buttons:

	- make room for buttons by changing #recipes_list_scroll height to 95%

	- add to body.rhtml
    <% view :sidebar_toolbar do -%>
  		<%= button_view :label => "+", :action => 'Cookbook.recipesController.addObject' %>
    <% end -%>

- add to recipe.js for default values

  init: function() {
    this.set('name','New Recipe');
    sc_super();
  }

- add to recipesController

  addObject: function() {
    var newObj = Cookbook.Recipe.newRecord({},Cookbook.server);
    this.pushObject(newObj);
    this.set('selection',[newObj]);
  }

- reload browser, add object - why no save button?

- add to recipeController

  saveable: function() {
    
    if (this.get('hasChanges')) { 
      return true;
    }
    
    var content = this.get('content');
    var save = false;

    if (content && content.get('length') == 1) {
      save = content.objectAt(0).get('newRecord');
    } 
    
    return save;
  }.property('hasChanges','content*newRecord')

- talk about computed properties and chained observers

- change save button to bind to "Cookbook.recipeController.saveable"

- reload browser, check button, but still need create action

  before_filter :decode_recipe, :only => [:create,:update]

  def create
		# this is just SproutCore's temporary guid; we'll return the persistent, real guid if this is successful
    @recipe_params.delete('guid') 
    recipe = Recipe.create!(@recipe_params)
    render :json => recipe.to_hash
  rescue ActiveRecord::RecordInvalid
    render :text => "Unable to create recipe due to #{$!.message}", :status => 403
  end

  private
  
  def decode_recipe
    @recipe_params = ActiveSupport::JSON.decode(params[:recipe])
    @recipe_params.delete('guid') # we use the URL id which is the same as the guid
  end

- now try saving, check Rails server log

- need auth token

- add recipe presetner index code for auth token

    if protect_against_forgery?
      response_hash[:rails_auth_token_name] = request_forgery_protection_token
      response_hash[:rails_auth_token] = form_authenticity_token
    end

- reload browser

- in console, type 
	SC.RAILS_AUTH_TOKEN

- add to executeAjax method

  opts.parameters = opts.parameters || {};

  if (opts.method != 'get') {
    opts.parameters[SC.RAILS_AUTH_TOKEN_NAME] = SC.RAILS_AUTH_TOKEN;
  } 

- now try to add and save

- notice that save button still enabled, need to add this to commit
   this.set('newRecord',false); // bug, SC.Store should be doing this for us

- now refactor commit to handle updates; hint you will need to change the HTTP verb and the URL
	based on the newRecord property

- add update action

  def update    
    recipe = Recipe.find(params[:id])

    if recipe.update_attributes(@recipe_params)
      render :json => recipe.to_hash
    else
      render :text => "Unable to update recipe due to #{recipe.errors.full_messages.join(". ")}", :status => 403
    end
  end

- now reload browser and try updating existing records

- now add delete button that calls the destroyObject action on recipes controller. It should only be enabled if the recipesController "hasSelection" property is true

- add to array controller

  destroyObject: function() {
    // step through each selected object and call its destruction method
    // provide a callback so that if the deletion is successful, the 
    // destroyed record is removed from our array
    var sel = this.get('selection');
    var idx = sel.length;
    var obj;
    
    while (idx--) {
      obj = sel[idx];
      obj.destroy(function() {
        this.removeObject(obj);
      }.bind(this));
    }
  },

- add to recipe model

  destroy: function(successFunction) {    
    var url = Cookbook.RECIPES_MEMBER_PATH.fmt(this.get('guid'));
    
    var opts = {
      onSuccess: function(transport) {
        if (successFunction) { successFunction(); }
        sc_super();
      }.bind(this),
      onFailure: function(transport) {
        console.warn("Recipe destroy failed due to: '%@'".fmt(transport.statusText));
      }
    };

    Cookbook.executeAjax(url,'delete',opts);  
  }

- add to recipes controller

  def destroy
    Recipe.destroy(params[:id])
    render :nothing => true
  end

- reload browser and try to destroy

- now we need a custom view

- at console type
 script/generate migration AddSpiceToRecipes spice:integer

- add spice: levels to recipes.yml
	may also want to add a few more objects here
	
- type rake db:migrate db:fixtures:load

- restart Rails server

- add to body above spice text
    <%= slider_view :minimum => 0, 
                      :maximum => 100, 
                      :bind => { :value => 'Cookbook.recipeController.spice' } %>
                      
- try savng the object, notice that the value flickers and changes back; why?

- change recipe model:
  properties: ['name','prep_time','cook_time','spice'],

- now let's save we want to display a meaningful text value

- type sc-gen view cookbook/spice_label SC.LabelView

- add to spice_label.js

  init: function () { sc_super(); this.render(); },
   
  render: function() {
    var html = '';
    var spice = this.get('content');

    // in JavaScript, 0 evaluates to false
    if (spice === undefined) {
      html = "Unknown";
    }

    if (spice < 50) {
      html = "Mild";
    } else if (spice < 75) {
      html = "Medium";
    } else {
      html = "Hot!";
    }

    this.set('innerHTML',html);
  }.observes('content')

- add to body.html below slider
      <%= view :view => 'Cookbook.SpiceLabelView', 
               :tag => 'span',
               :bind => { :content => 'Cookbook.recipeController.spice' } %>

- reload browser and play with slider

- type sc-build and investigate public dir

EXERCISES
	- setup a computed property on recipe that shows a label whether the recipe is "elaborate" or not
		based on the total cookng time
		
	- have executeAjax increment a value for each reqeust that gets decremented on completion,
		displaying an ajax spinner while that value is greater than 0

	- change arranged objects based on a toggle button

	- add an automatic refresh that asks for newly-created recipes from the server
	
LAST 30 MINUTES
- SC 1.0 API diffs
- review OIB code

TODO
- check proper invalid data response, is 403 the right code?
- custom view for stale/pending etc
- mouseUp/mouseDown
- app page title
- investigate HTML5 store?
- write unit tests for recipe

For futher refinement
	- rescue action in public for ActiveRecord::RecordNotFound